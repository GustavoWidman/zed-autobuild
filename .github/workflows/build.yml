name: Build and Cache Zed

on:
  schedule:
    # Check for new releases every 6 hours
    - cron: "0 */6 * * *"
  workflow_dispatch:
  push:
    branches:
      - main
    paths:
      - ".github/workflows/build-and-cache.yml"

concurrency:
  group: build-zed
  cancel-in-progress: false

jobs:
  check-new-release:
    name: Check for new Zed release
    runs-on: ubuntu-latest
    outputs:
      has_new_release: ${{ steps.check.outputs.has_new_release }}
      new_tag: ${{ steps.check.outputs.new_tag }}
      current_tag: ${{ steps.check.outputs.current_tag }}
    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Check for new release
        id: check
        run: |
          # Get current tag from .current file
          CURRENT_TAG=$(cat .current || echo "v0.0.0")
          echo "Current tag: $CURRENT_TAG"
          echo "current_tag=$CURRENT_TAG" >> $GITHUB_OUTPUT

          # Get latest Zed release tag
          LATEST_TAG=$(curl -s https://api.github.com/repos/zed-industries/zed/releases | jq -r '.[0].tag_name')
          echo "Latest tag: $LATEST_TAG"
          echo "new_tag=$LATEST_TAG" >> $GITHUB_OUTPUT

          # Compare
          if [ "$CURRENT_TAG" != "$LATEST_TAG" ]; then
            echo "New release found: $LATEST_TAG"
            echo "has_new_release=true" >> $GITHUB_OUTPUT
          else
            echo "No new release"
            echo "has_new_release=false" >> $GITHUB_OUTPUT
          fi

  build-and-push:
    name: Build ${{ matrix.system }}
    needs: check-new-release
    if: needs.check-new-release.outputs.has_new_release == 'true'
    runs-on: ${{ matrix.runner }}
    strategy:
      fail-fast: false
      matrix:
        include:
          - system: x86_64-linux
            runner: ubuntu-latest
          - system: aarch64-linux
            runner: ubuntu-latest # Use QEMU or native ARM runner if available
          - system: x86_64-darwin
            runner: macos-13 # Intel Mac
          - system: aarch64-darwin
            runner: macos-14 # ARM Mac
    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Install Nix
        uses: DeterminateSystems/nix-installer-action@main
        with:
          extra-conf: |
            substituters = https://cache.nixos.org/ https://nix-community.cachix.org https://cache.garnix.io
            trusted-public-keys = cache.nixos.org-1:6NCHdD59X431o0gWypbMrAURkbJ16ZPMQFGspcDShjY= nix-community.cachix.org-1:mB9FSh9qf2dCimDSUo8Zy7bkq5CX+/rkCWyvRCYg3Fs= cache.garnix.io:CTFPyKSLcx5RMJKfLo5EEPUObbA78b0YQ2DTCJXqr9g=
            cores = 0
      - uses: DeterminateSystems/magic-nix-cache-action@main
      - name: Setup QEMU for aarch64 builds
        if: matrix.system == 'aarch64-linux' && runner.os == 'Linux'
        run: |
          sudo apt-get update
          sudo apt-get install -y qemu-user-static binfmt-support

      - name: Update flake to new tag
        run: |
          NEW_TAG="${{ needs.check-new-release.outputs.new_tag }}"

          # Update the zed input in flake.nix
          sed -i "s|zed.url = \"github:zed-industries/zed/.*\"|zed.url = \"github:zed-industries/zed/$NEW_TAG\"|g" flake.nix

          # Update flake.lock
          nix flake update zed

          cat flake.nix | grep "zed.url"

      - name: Build Zed for ${{ matrix.system }}
        run: |
          if [ "${{ matrix.system }}" = "aarch64-linux" ] && [ "$(uname -m)" != "aarch64" ]; then
            # Cross-compile for aarch64-linux
            nix build .#packages.aarch64-linux.default \
              --option system x86_64-linux \
              --builders "" \
              -L
          else
            # Native build
            nix build .#default -L
          fi

      - name: Push to binary cache
        env:
          NIX_SIGNING_KEY: ${{ secrets.NIX_SIGNING_KEY }}
        run: |
          # Configure signing key
          echo "$NIX_SIGNING_KEY" > /tmp/nix-signing-key.sec

          # Get the store path
          STORE_PATH=$(nix eval --raw .#packages.${{ matrix.system }}.default.outPath || nix eval --raw .#default.outPath)
          echo "Store path: $STORE_PATH"

          # Sign the path
          nix store sign \
            --key-file /tmp/nix-signing-key.sec \
            --recursive \
            "$STORE_PATH"

          # Push to your cache (adjust command for your cache type)
          # For attic:
          # attic push your-cache-name "$STORE_PATH"

          # For a simple HTTP cache:
          # nix copy --to "s3://your-bucket?region=us-east-1" "$STORE_PATH"

          # For harmonia/nix-serve:
          nix copy --to "http://YOUR-CACHE-URL" "$STORE_PATH"

          # Clean up signing key
          rm /tmp/nix-signing-key.sec

  update-current-tag:
    name: Update .current file
    needs: [check-new-release, build-and-push]
    if: needs.check-new-release.outputs.has_new_release == 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Install Nix
        uses: cachix/install-nix-action@v26

      - name: Update files
        run: |
          NEW_TAG="${{ needs.check-new-release.outputs.new_tag }}"

          # Update .current
          echo "$NEW_TAG" > .current

          # Update flake.nix
          sed -i "s|zed.url = \"github:zed-industries/zed/.*\"|zed.url = \"github:zed-industries/zed/$NEW_TAG\"|g" flake.nix

          # Update flake.lock
          nix flake update zed

      - name: Commit and push changes
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"

          git add .current flake.nix flake.lock
          git commit -m "chore: update to ${{ needs.check-new-release.outputs.new_tag }}"
          git push
